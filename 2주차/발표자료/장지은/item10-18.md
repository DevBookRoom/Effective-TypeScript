## item10. 객체 래퍼 타입 피하기

### 기본형과 객체래퍼

```tsx
'primitive'.charAt(3) // "m"
```

JS는 일곱가지 기본형을 가진다 (string, number, boolean, null, undefined, symbol, bigint)

기본형들은 메서드를 가지지 않지만, .charAt을 사용 가능한 이유는 JS가 기본형을 **String(객체래퍼)** 로 래핑했기 때문

string 외의 다른 기본형들도 동일하게 래퍼타입이 존재한다

- string → String
- number → Number
- boolean → Boolean
- symbol → Symbol
- bigint → BigInt

### 타입스크립트의 기본형/객체래퍼 타입 모델링

TS는 기본형과 객체 래퍼타입을 별도로 모델링한다.

```tsx
function isGreeting(phrase: String) {
  return ['hello', 'good day'].includes(phrase); // Argument of type 'String' is not assignable to parameter of type 'string'.
}
```

string은 String에 할당할 수 있지만, 반대는 불가능하다. 따라서 string을 매개변수로 받는 메서드에 String객체를 전달하면 문제가 발생한다. 따라서 TS에선 기본형타입을 사용하는 것이 더 낫다

## item11. 잉여 속성 체크의 한계 인지하기

### 객체 리터럴의 잉여속성 체크

타입이 명시된 변수에 객체 리터럴을 할당할 때  TS는 잉여 속성이 없는지를 확인한다

```tsx
interface Room {
  numDorrs: number;
  ceilingHeightFt: number;
};

// 1. 객체 리터럴
const r: Room = {
  numDorrs: 1,
  ceilingHeightFt: 10,
  elephant: 'elephant'
}; // ❌오류 - Object literal may only specify known properties, and 'elephant' does not exist in type 'Room'.

// 2. 임시 변수 사용 (객체리터럴X)
const obj = {
  numDorrs: 1,
  ceilingHeightFt: 10,
  elephant: 'elephant'
};
const obj2: Room = obj; // ✅정상 - 구조적 타이핑 관점에서 오류가 발생하지 않음
const o = {numDorrs:1, ceilingHeightFt:10, elephant: 'elephant'} as Room; // ✅정상 - 타입 단언문을 사용하면 잉여속성체크X
```

TS에서 잉여속성체크와 할당가능 검사는 별도의 과정이다. 

첫번째 객체 리터럴의 케이스에선 **잉여속성 체크**가 수행되었다. 
하지만 객체리터럴이 아닌 두번째 케이스에선 잉여속성 체크가 적용되지 않고, 구조적 타이핑 관점에서 통과된다.
또 타입단언문을 사용할때도 잉여속성체크는 적용되지 않음

### 함수 매개변수의 잉여속성 체크

```tsx
interface Options {
  title: string;
  darkMode?: boolean;
}
function createWindow(options: Options) {
  if(options.darkMode) {
    // 어두운 모드 처리
  }
}

// 함수 매개변수
createWindow({ title: 'My App', darkmode: true }); // ❌오류 - Object literal may only specify known properties, but 'darkmode' does not exist in type 'Options'. Did you mean to write 'darkMode'?ts(2561)
```

함수 매개변수에서도 객체리터럴처럼 잉여속성 체크 진행함

### 약한 타입에서의 공통속성 체크

```tsx
interface LineChartOptions {
  logscale? :boolean;
  areaChart?: boolean;
} // week type - 선택적 속성만 가짐
const opts = {logScale: true};
const o: LineChartOptions = opts; // ❌오류 - Type '{ logScale: boolean; }' has no properties in common with type 'LineChartOptions'.ts(2559)
```

약한 타입이란, 선택적 속성만을 가지는 타입을 말한다. 구조적 타이핑 관점에선 모던 속성이 선택적이라면 모든 객체를 포함할 수 있다.

이런 약한타입에선 **공통된 속성이 있는지 확인하는 별도의 체크**를 수행한다. 이는 약한 타입과 관련된 할당문마다 수행된다.

## item12. 함수 표현식에 타입 적용하기

### 함수 문장과 함수 표현식

JS & TS는 함수 문장(satatement)와 함수 표현식(expression)을 다르게 인식한다

```tsx
function rollDice1(slides: number) : number { return Math.ceil(Math.random() * slides);} // 함수 문장
const rollDice2 = function(slides: number) : number { return Math.ceil(Math.random() * slides);} // 함수 표현식
const rollDice3 = (slides: number): number => { return Math.ceil(Math.random() * slides);} // 함수 표현식 - 화살표 함수

// 함수를 type으로 선언
type DiceRollFn = (slides: number) => number;
const rollDice: DiceRollFn = (slides) => Math.ceil(Math.random() * slides); // 👍 slides가 number로 인식됨
```

함수매개변수 & 반환값까지 타입으로 선언해두면 재사용이 가능하기 때문에ㅔ TS에선 함수표현식을 쓰는게 더 유리하다. 

### 다른 함수의 시그니처 참조하기

라이브러리는 공통함수시그니처를 타입으로 제공하기도 한다. (ex: mouseEventHandler - 이벤트핸들러 함수 전체에 적용 가능)

시그니처가 일치하는 다른 함수가 있으면 함수표현식에 해당 시그니처 타입을 적용하는게 좋다

```tsx
// 브라우저의 fetch의 타입선언 (lib.com.d.ts)
declare function fetch(input: RequestInfo, init?: RequestInit): Promise<Response>;

// typeof 연산자로 fetch의 시그니처 참조
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);
  if(!response.ok) {
    throw new Error('Network response was not ok');
  }
  return response;
}
```

## item13. 타입과 인터페이스의 차이점

### 명명된 타입을 정의하는 방법

```tsx
// 1. Type
type Tstate = {
  name: string;
  capital: string;
}
// 2. Interface
interface Istate {
  name: string;
  capital: string;
}
```

TS에서 타입을 정의하는 방법은 타입 & 인터페이스 두가지가 있다. 

### 타입과 인터페이스의 공통점

- 추가 속성과 함께 할당한다면, 동일한 오류가 발생함
- 인덱스 시그니처 사용 가능
- 제네릭 사용 가능
- 인터페이스는 타입을 확장할 수 있고, 타입은 인터페이스를 확장할 수 있다.
    - ❗️인터페이스는 유니온타입같은 복잡한 타입은 확장하지 못함
- 클래스를 구현(implements)할 땐 타입과 인터페이스 둘다 사용 가능

### 타입과 인터페이스의 차이점

- 유니온 타입은 있지만, 유니온 인터페이스는 없다.
    
    ```tsx
    type Input = { /** */}
    type Output = { /** */}
    interface VariableMap { 
      [name: string] : Input | Output;
    }
    
    // 유니온 타입에 name 속성을 붙인 타입 -> Interface로 표현 불가능
    type NamedVariable = (Input | Output) & {name: string};
    ```
    
- 인터페이스는 보강(augment)이 가능하다.
    
    ```tsx
    interface IState {
      name: string;
      capital: string;
    }
    // ✅ 선언 병합 (속성 확장)
    interface IState {
      population: number;
    } 
    const wyoming: IState = {
      name: 'Wyoming',
      capital: 'Cheyenne',
      population: 500000,
    }
    
    ```
    
    인터페이스는 다음과 같이 **선언 병합 (declaration merging)**을 통해 속성을 확장할 수 있다. 
    
    실제로 TS는 JS의 표준라이브러리에서 여러 타입들을 모아 병합한다. tsconfig의 lib목록에 ES2015를 추가하면, *lib.es5.d.ts*의 Array 인터페이스에 *lib.es2015.d.ts*의 Array 인터페이스를 병합한다. 
    

### 타입과 인터페이스, 무엇을 사용하는게 좋을까?

복잡한 타입이라면 type별칭을 사용하는 것이 좋다. 하지만 간단한 객체 타입이라면, interface의 일관성과 보강의 관점을 고려해봐야한다.