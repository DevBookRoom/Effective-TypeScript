## item19. 추론 가능한 타입을 사용해 장황한 코드 방지하기

### TS가 추론 가능한 경우들

타입스크립트가 추론 가능한 타입들은 타입구문이 사실 불필요하다.

```tsx
let x = 12; // x:number로 이미 추론되어있음

const person = {
  name: "홍길동", // name: string
  born: {
    where: "서울", // where: string
    when: "2023-01-01", // when: string
  },
};
```

함수의 리턴타입이 명확한 경우에도, 타입추론이 가능하기 때문에 따로 명시할 필요가 없다.

```tsx
function square(nums: number[]) {
  return nums.map((num) => num * num);
}

const squareNumbers = square([1, 2, 3, 4, 5]); // squareNumbers: number[]로 이미 추론
```

매개변수에 기본값이 있는 경우도 타입구문 생략 가능

```tsx
function parseNumber(str: string, base = 10) {
  // base: number로 자동 추론
  return parseInt(str, base);
}
```

타입정보가 있는 라이브러리를 사용하는 경우, 콜백함수의 매개변수타입은 자동으로 추론된다.

```tsx
// ❌ express HTTP 서버 라이브러리에서 해당 타입선언은 불필요함
app.get("/health", (req: express.Request, res: express.Response) => {
  res.send("ok");
});

// ✅ 타입선언 없어도 추론 가능하다
app.get("/health", (req, res) => {
  res.send("ok");
});
```

### 비구조화 할당문 활용

타입이 추론되면 타입을 명시하지 않는것이 리팩토링도 더 쉬워진다.

```tsx
interface Product {
  id: number;
  name: string;
  price: number;
}
```

타입 명시한 케이스

```tsx
function logProduct(product: Product) {
  const id: number = product.id;
  const name: string = product.name;
  const price: number = product.price;
  console.log(`${id} ${name}의 가격은 ${price}원입니다.`);
}
```

- id가 string으로 바뀔 경우, logProduct 함수 내의 타입까지 수정 필요

비구조화 할당문

```tsx
function logProduct2(product: Product) {
  const { id, name, price } = product;
  console.log(`${id} ${name}의 가격은 ${price}원입니다.`);
}
```

- 비구조화 할당문은 변수의 타입이 추론되도록 함
- 매개변수의 타입 Product만 지정하는것으로 충분하다!
- id가 string으로 바뀌어도 해당 함수는 수정될 필요❌, 유지보수가 쉬워진다

### 타입 명시하는게 좋은 케이스

객체 리터럴 정의할 땐 타입을 명시하는게 좋다. 만약 객체리터럴을 선언할 때 타입구문을 제거한다면, 객체를 선언한 곳이 아니라 사용되는 곳에서 타입오류가 발생할 수 있다.

```tsx
interface Product {
  id: string;
  name: string;
  price: number;
}

// 객체 리터럴에 타입구문X
const furby = {
  id: 200222, // id를 string이 아닌 number로 선언! - 리터럴에 타입을 명시했다면, 해당 선언부에서 에러가 발생한다
  name: "Furby",
  price: 20000,
};
logProduct(furby); // ❌ 선언부가 아니라 실제 사용하는 곳에서 에러가 발생한다! - 디버깅 어려움
```

함수 반환타입 명시하면 오류를 사전에 발견하여 에러방지할 수 있다.

조건에 따라 리턴타입이 다르게 나오지만, return type을 명시하지 않아 ts는 에러를 잡아주지 않는다.

```tsx
const cache: { [ticker: string]: number } = {};
function getQuote(ticker: string) {
  if (cache[ticker]) {
    // ❓❓❓ return number
    return cache[ticker];
  }
  // ❓❓❓ return Promise<number>
  return fetch("https://api.example.com/quote?ticker=" + ticker)
    .then((response) => response.json())
    .then((data) => {
      cache[ticker] = data;
      return data;
    });
}
```

리턴타입을 명시하면 해당 오류를 미리 발견할 수 있다!

```tsx
const cache: { [ticker: string]: number } = {};
function getQuote(ticker: string): Promise<number> {
  if (cache[ticker]) {
    // return cache[ticker]; // ❌ 오류발생!! - Type 'number' is not assignable to type 'Promise<number>'.
    return Promise.resolve(cache[ticker]); // ✅ 해결방법 - Promise.resolve를 사용하여 즉시 해결
  }
  return fetch("https://api.example.com/quote?ticker=" + ticker)
    .then((response) => response.json())
    .then((data) => {
      cache[ticker] = data;
      return data;
    });
}
```

---

## item20. 다른 타입에는 다른 변수 사용하기

```tsx
// ❌ Don't
let id = "12-34-56";
fetchProduct(id);
id = 123456;
fetchProductBySerialNumber(id);
```

```tsx
// ✅ Do
const id = "123456"; // string
fetchProduct(id);
const serial = 123456; // number
fetchProductBySerialNumber(serial);
```

- 서로 관련없는 값은 분리한다 (id, serial)
- 변수명은 구체적으로 짓는다
- 타입추론을 향상시키면 타입구문이 불필요해지고, 타입이 더 간결해진다
- let 대신 const로 변수를 선언하게 되고, 이는 타입체커가 타입을 추론하기 좋다

---

## item21. 타입 넓히기

### 타입 넓히기란?

상수를 이용해서 변수를 초기화할 때 타입을 명시하지 않으면 타입체커는 타입을 결정해야 한다.

즉, 지정된 단일값을 가지고 할당 가능한 값들의 집합을 유추해야한다. == TS의 넓히기 과정 (widening)

```tsx
interface Vector3 {
  x: number;
  y: number;
  z: number;
}
function getComponent(vector: Vector3, axis: "x" | "y" | "z") {
  return vector[axis];
}

let x = "x"; // 넓히기 시점에 string으로 추론됨
let vec = { x: 1, y: 2, z: 3 };
getComponent(vec, x); // ❌ 오류발생! - Argument of type 'string' is not assignable to parameter of type '"x" | "y" | "z"'
```

x는 할당 시점에 넓히기 과정을 통해 string으로 추론되지만, getComponent의 axis "x" | "y" | "z"타입에 할당이 불가능하여 오류가 발생한다.

### 타입 넓히기 제어하기

const를 이용하면 넓히기 과정을 제어할 수 있다.

let 대신 const로 변수를 선언하면, 해당 변수는 재할당 될 수 없으므로 더 좁은 타입이 된다.

```tsx
const x = "x"; // ✨ const로 선언하여 string이 아니라 "x"타입으로 할당됨
let vec = { x: 1, y: 2, z: 3 };
getComponent(vec, x); // ✅ 오류 없음
```

객체와 배열의 경우엔 const로도 제어가 되지 않는 경우가 있다.

TS넓히기 알고리즘은 객체의 각 요소를 let으로 할당된 것처럼 다룬다.

```tsx
const v = { x: 1 }; // x는 let처럼 다루어짐 => x: number

v.x = 2; // ✅ 오류 없음 - x는 number타입이므로 할당 가능
v.x = "x"; // ❌ 오류발생! - Type 'string' is not assignable to type 'number'.
v.y = 4; // ❌ 오류발생! - Property 'y' does not exist on type '{ x: number; }'.
v.name = "rachel"; // ❌ 오류발생! - Property 'name' does not exist on type '{ x: number; }'.
```

객체/배열의 타입추론의 강도를 직접 제어하는 방법은

1. 명시적 타입구문을 제공하기

   ```tsx
   const v: { x: 1 | 3 | 5 } = {
     x: 1,
   }; // v의 타입은 { x: 1|3|5}
   ```

2. 타입체커에 추가적인 문맥을 제공하기 (함수의 매개변수로 값 전달 등) → item26 타입추론과정에서 자세히 다룸
3. const 단언문 사용하기

   ```tsx
   const v1 = {
     x: 1,
     y: 2,
   }; // v1의 타입은 { x: number, y: number }

   const v2 = {
     x: 1 as const,
     y: 2,
   }; // v2의 타입은 { x: 1, y: number }

   const v3 = {
     x: 1,
     y: 2,
   } as const; // v3의 타입은 { readonly x: 1, readonly y: 2 }
   ```

   ```
   const a1 = [1, 2, 3]; // a1의 타입은 (number)[]
   const a2 = [1, 2, 3] as const; // a2의 타입은 readonly [1, 2, 3]
   ```

   값 뒤에 as const를 작성하면, TS는 최대한 좁은 타입으로 추론한다. as const를 사용하여 넓히기로 인한 오류를 줄일 수 있다.

---

## item22. 타입 좁히기

타입 좁히기는 TS가 넓은 타입으로부터 좁은 타입으로 진행하는 과정을 말한다.

### null체크

null체크는 대표적인 타입좁히기의 예시이다. 분기에 따라 변수의 타입을 좁혀 추론할 수 있다.

```tsx
const el = document.getElementById("foo"); // el의 타입은 HTMLElement | null
if (el) {
  el; // el: HTMLElement
} else {
  el; // el: null
}
```

### instanceof

instanceof를 이용하여 타입을 좁힐 수 있다.

```tsx
function contains(text: string, search: string | RegExp) {
  if (search instanceof RegExp) {
    search; // search: RegExp
    return !!search.exec(text);
  }
  search; // search: string
  return text.includes(search);
}
```

### 속성체크 (in)

속성체크를 사용해도 타입을 좁힐 수 있다.

```tsx
interface A {
  a: number;
}
interface B {
  b: number;
}

function pickAB(ab: A | B) {
  if ("a" in ab) {
    ab; // ab: A
  } else {
    ab; // ab: B
  }
  ab; // ab: A | B
}
```

### isArray같은 내장함수 이용하기

Array.isArray같은 일부 내장함수를 이용하여도 타입을 좁힐 수 있다.

```tsx
function contains(text: string, term: string | string[]) {
  const termList = Array.isArray(term) ? term : [term]; // termList: string[]
  return termList.some((t) => text.includes(t));
}
```

### 명시적 태그 붙이기

태그된 유니온 or 구별된 유니온이라고 불리는 이 패턴을 이용하여 타입을 좁힐 수 있다.

```tsx
interface UploadEvent {
  type: "upload";
  filename: string;
}
interface DownloadEvent {
  type: "download";
  filename: string;
}
type AppEvent = UploadEvent | DownloadEvent;

function handleEvent(e: AppEvent) {
  switch (e.type) {
    case "upload":
      console.log(e.filename); // e: UploadEvent
      break;
    case "download":
      console.log(e.filename); // e: DownloadEvent
      break;
  }
}
```

### 사용자 정의 타입가드 (커스텀 함수 도입)

만약 isInputElement의 함수 반환이 true인 경우, 타입체커에서 매개변수 타입을 HTMLInputElement로 좁힐 수 있다고 알려준다.

```tsx
function isInputElement(element: HTMLElement): element is HTMLInputElement {
  return "value" in element;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    return el.value; // el: HTMLInputElement
  }
  return el.textContent; // el: HTMLElement
}
```

<aside>
💡

is는 Type Predict 구문이다.

**return 값이 `true`라면, type predicate에 적은 말 그대로 '함수가 호출된 범위 내에선 `element`를 `HTMLInputElement`타입으로 보라’**

https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates

</aside>

### 타입가드

타입가드를 이용하면 배열과 객체의 타입 좁히기를 할 수 있다.

```tsx
const jackson5 = ["Jackie", "Tito", "Jermaine", "Marlon", "Michael"];
const members = ["Janet", "Michael"].map((who) =>
  jackson5.find((name) => name === who)
); // result: [undefined, "Michael"], type: (string | undefined)[]
```

배열의 탐색에서 undefined가 될 수 있기에, 타입은 (string | undefined)[]가 된다.

```tsx
const members2 = ["Janet", "Michael"]
  .map((who) => jackson5.find((name) => name === who))
  .filter((who) => who !== undefined);
// result: ["Michael"], type: string[] ❓❓❓된다..
```

.filter를 통해 undefined를 걸러내어 타입은 string[] (책에선 안된다고했는데 됨..)

```tsx
function isDefined<T>(x: T | undefined): x is T {
  return x !== undefined;
}
const memebers3 = ["Janet", "Michael"]
  .map((who) => jackson5.find((name) => name === who))
  .filter(isDefined); // result: ["Michael"], type: string[]
```

타입가드 (x is T)를 사용하면 undefined 타입이 명시적으로 걸러지면서 타입은 string[]이 된다.

---

## item23. 한꺼번에 객체 생성하기

### 객체의 여러 속성을 한꺼번에 생성하자

객체를 생성할 때 속성을 하나씩 생성하기보다는, 여러 속성을 한꺼번에 생성해야 타입 추론에 유리하다.

```tsx
// 👎 객체 속성을 하나씩 생성
const pt = {};
pt.x = 1; // ❌ 오류발생! - Property 'x' does not exist on type '{}'.
pt.y = 2; // ❌ 오류발생! - Property 'y' does not exist on type '{}'.

// 👍 여러 속성을 한꺼번에 생성
const pt2 = { x: 3, y: 4 }; // ✅ pt2의 타입은 { x: number, y: number }로 추론됨
```

위의 pt타입은 {} 를 기준으로 추론되므로 x와 y를 추가하려할 때 에러가 발생하지만, pt2처럼 객체를 한꺼번에 정의하면 타입이 정상적으로 추론된다.

```tsx
interface Point {
  x: number;
  y: number;
}

// 👎 타입 단언문 (as) 사용
const pt3 = {} as Point;
pt3.x = 1; // ✅ 오류 없음
pt3.y = 2; // ✅ 오류 없음

// 👍 객체 한꺼번에 만들기
const pt4: Point = { x: 1, y: 2 };
```

interface를 활용하는 경우에도 타입단언문 as를 활용하면 추후에 속성을 하나씩 추가하여도 타입체커를 피해갈 수 있지만, 그래도 한꺼번에 만드는게 더 낫다.

### 객체 전개연산자 이용하기

작은 객체들을 조합해서 큰 객체를 만들어야하는 경우엔 객체전개연산자(…)을 활용하는게 좋다.

```tsx
const pt = { x: 1, y: 2 };
const id = { name: "point1" };

// 👎 namedPoint 타입은 {}로 추론되어 에러 발생
const namedPoint = {};
Object.assign(namedPoint, pt, id);
namedPoint.name = "point1"; // ❌ 오류발생! - Property 'name' does not exist on type '{}'.

// 👍 객체 전개 연산자로 한번에 할당 - 타입 추론 가능
const namedPoint2 = { ...pt, ...id }; // ✅ namedPoint2의 타입은 { x: number, y: number, name: string }로 추론됨
```

### 조건부 속성 추가하기

타입에 안전한 방식으로 조건부 속성을 추가하기 위해선 속성을 추가하지 않는 null 또는 {}로 객체 전개를 사용하면 된다.

```tsx
declare let hasMiddle: boolean;
const firstLast = { first: "Abraham", last: "Lincoln" };
const president = { ...firstLast, ...(hasMiddle ? { middle: "Middle" } : {}) }; // ✅ middle타입이 조건부 속성으로 추가됨! - { first: string, last: string, middle?: string }
```

전개 연산자로 한꺼번에 여러개의 속성을 추가할 수 있다.

```tsx
declare let hasDates: boolean;
const nameTitle = { name: "Sejong", title: "King" };
const king = {
  ...nameTitle,
  ...(hasDates ? { start: "1418", end: "1450" } : {}),
};
```

- 실제 Output

```tsx
// 추론된 king type - ❓책과 다름
const king: {
  start?: string | undefined;
  end?: string | undefined;
  name: string;
  title: string;
};
```

- 책 version - start와 end가 항상 함께 정의되기 때문에, 유니온으로 표현하는게 가능한 값의 집합을 더 정확히 표현한다

```tsx
const king:
  | {
      start: string;
      end: string;
      name: string;
      title: string;
    }
  | {
      name: string;
      title: string;
    };
```

핼퍼함수를 이용하면 선택적 필드를 더 명시적으로 나타낼 수 있다.

```tsx
// Helper 함수
function addOptional<T extends object, U extends object>(
  a: T,
  b: U | null
): T & Partial<U> {
  return { ...a, ...b };
}

const king2 = addOptional(
  nameTitle,
  hasDates ? { start: "1418", end: "1450" } : null
);

king2.start; // string | undefined
```

---
