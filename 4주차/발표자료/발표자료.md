# 4장. 타입 설계

## item28. 유효한 상태만 표현하는 타입을 지향하기

타입을 잘 설계하면 코드를 직관적으로 작성할 수 있다.

효과적으로 타입을 설계하려면 유효한 상태만 표현할 수 있는 타입을 만들어내는 것이 좋다.

- 무효한 상태를 포함하도록 타입설계한 CASE

  ```
  interface State {
    pageText: string;
    isLoading: boolean; // loading 상태
    error?: string; // 에러 메시
  }

  function renderPage(state: State) {
    if (state.error) {
      return <div>{state.error}</div>; // ❓🤷‍♀️ - isLoading도 true, error도 true이면?
    } else if (state.isLoading) {
      return <div>Loading...</div>;
    }
    return <div>{state.pageText}</div>;
  }
  ```

  isLoading과 error 두가지 속성이 충돌한다. (오류이면서 동시에 로딩중일 수 있음 == 무효한 상태)

  이런 무효한 상태가 존재한다면 제대로 구현할 수 없다.

- 무효한 상태 X인 CASE

  ```tsx
  interface RequestPending {
    state: "pending";
  }
  interface RequestSuccess {
    state: "ok";
    pageText: string;
  }
  interface RequestError {
    state: "error";
    error: string;
  }
  type RequestState = RequestPending | RequestSuccess | RequestError; // 태그된 유니온 타입

  interface State {
    currentPage: string;
    requests: {
      [url: string]: RequestState; // url별로 요청 상태를 저장
    };
  }

  function renderPage(state: State) {
    const { currentPage } = state;
    const currentRequest = state.requests[currentPage];
    if (currentRequest.state === "pending") {
      return <div>Loading...</div>;
    } else if (currentRequest.state === "ok") {
      return <div>{currentRequest.pageText}</div>;
    } else {
      return <div>{currentRequest.error}</div>;
    }
  }
  ```

  state가 currentRequest.state 하나로 관리되기 때문에, 무효한 상태를 허용하지 않도록 개선되었다.
  코드가 길어지거나 표현하기 어려울 수 있지만, 시간을 줄일 수 있기때문에 이 방식을 채택해야한다.

---

## item29. 사용할 때는 너그럽게, 생성할 때는 엄격하게

함수의 매개변수는 타입의 범위가 넓어도 되지만, 결과를 반환할 때는 타입의 범위가 더 구체적이여야 한다.

### 자유로운 타입의 매개변수 받기

```tsx
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;

// 자유로운 타입의 매개변수
interface CameraOptions {
  center?: LangLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}

type LangLat =
  | { lat: number; lng: number }
  | { lon: number; lat: number }
  | [number, number];

type LngLatBounds =
  | { northeast: LangLat; southwest: LangLat }
  | [LangLat, LangLat]
  | [number, number, number, number];
```

- CameraOptions의 값은 모두 선택적이어서, 값을 건드리지 않으며 다른 값 설정 가능
- LngLat타입도 `{lng, lat}`, `{lon, lat}`, `[lng,lot]` 모두 넣을수 있어 편리함

### 생성될 때의 반환타입도 너무 자유롭다면?

```tsx
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;

function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds); // 👎 반환 타입이 CameraOptions로, 너무 자유로움!
  setCamera(camera);

  const {
    center: { lat, lng }, // // ❌ Property 'lat' does not exist on type 'LangLat | undefined'
    zoom,
  } = camera;

  zoom; // 👎 타입이 number | undefined
  window.location.search = `?lat=${lat}&lng=${lng}&zoom=${zoom}`;
}
```

- CameraOption의 center속성이 선택적이기 때문에, center의 타입이 `LangLat | undefined`
- zoom 또한 `number|undefined`로 추론됨

⇒ viewportForBounds의 타입선언이 사용될 때 뿐 아니라 만들어질 때도 너무 자유로운것이 문제를 일으킨다.

⇒ 매개변수의 타입이 넓으면 사용하기 편리하지만, 반환타입의 범위가 넓으면 불편하다. 따라서 반환타입을 엄격하게 적용해야한다.

### 생성될 때의 반환타입을 엄격하게 적용하기

유니온 타입의 요소별 분기를 위한 방벙은, 기본 형식을 따로 구분하는 것이다.

기본 형태를 반환타입으로 쓰고, 느슨한 형태를 매개변수타입으로 사용하는게 좋다.

```tsx
// 좌표의 기본 형식
interface LngLat {
  lat: number;
  lng: number;
}
// 더 자유로운 형식 포함한 느슨한 타입
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];
type LngLatBounds =
  | { northeast: LngLatLike; southwest: LngLatLike }
  | [LngLatLike, LngLatLike]
  | [number, number, number, number];
```

- “배열같은것”의 사용을 위해 ArrayLike를 사용했던 것 처럼, `LngLat`과 `LngLatLike`로 구분

  - 🤖GPT설명 - Type & TypeLike
    TypeScript에서 Type과 TypeLike 패턴은 타입 시스템의 중요한 설계 관례입니다.

    - **기본관례**
      1. **기본 타입 (Type)**:
         - 정확하고 엄격한 구조를 가진 타입
         - 명확한 속성과 동작을 정의
         - 일관된 인터페이스 제공
      2. **유연한 타입 (TypeLike)**:
         - 기본 타입을 포함하는 유니온 타입
         - 유사하지만 구조가 조금 다른 여러 형태 허용
         - 더 넓은 범위의 입력값 수용
    - **주요 특징**
      - **호환성**: TypeLike는 항상 Type과 호환됨 (Type은 TypeLike의 부분집합)
      - **방향성**: 엄격한 내부 구현 → 유연한 외부 API
      - **사용 문맥**: 주로 함수 매개변수에 TypeLike, 반환 값에 Type 사용
    - **자주 사용되는 예시**

      1. **Array와 ArrayLike**

         ```tsx
         // Array: 모든 배열 메서드 포함*
         const arr: Array<number> = [1, 2, 3];
         // ArrayLike: length와 인덱스 접근만 가능*
         const arrLike: ArrayLike<number> = { 0: 1, 1: 2, 2: 3, length: 3 };
         ```

      2. **Promise와 PromiseLike**

         ```tsx
         // Promise: 완전한 Promise API
         const p: Promise<string> = new Promise((resolve) => resolve("done"));

         // PromiseLike: then 메서드만 있으면 됨
         const pLike: PromiseLike<string> = {
           then(onfulfilled) {
             return onfulfilled("done");
           },
         };
         ```

- LngLatBounds를 생성하는 다른 함수가 있다면, `LngLatBounds`와 `LngLatBoundsLike`로 구분하면 됨

```tsx
// Camera의 기본 형식
interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}
// 더 자유로운 형식을 포함한 느슨한 타입
interface CameraOptions extends Omit<Partial<Camera>, "center"> {
  center?: LngLatLike;
}
```

- 완벽하게 정의된 `Camera`와, 부분적으로 정의된 `CameraOptions`를 구분
  - 🤖GPT설명 -  CameraOptions extends Omit<Partial<Camera>, "center">
    1. Partial<Camera>
       - Partial은 타입의 모든 속성을 선택적(optional)으로 만듭니다.
       - Camera 인터페이스의 모든 속성(center, zoom, bearing, pitch)이 선택적이 됩니다.
         ```tsx
         {
         	center?: LngLat;
         	zoom?: number;
         	bearing?: number;
         	pitch?: number;
         }
         ```
    2. Omit<Partial<Camera>, "center">
       - Omit은 타입에서 특정 속성을 제외합니다.
       - Partial<Camera>에서 "center" 속성을 제외합니다.
         ```tsx
            {
              zoom?: number;
              bearing?: number;
              pitch?: number;
            }
         ```
    3. interface CameraOptions extends Omit<Partial<Camera>, "center">
       - Camera 인터페이스의 대부분의 속성을 상속받되, center 속성만 특별하게 처리합니다.
       - 모든 속성이 선택적(optional)입니다.
         ```tsx
            {
              center?: LngLatLike;      // 선택적
              zoom?: number;            // 선택적
              bearing?: number;         // 선택적
              pitch?: number;           // 선택적
            }
         ```

```tsx
declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): Camera; // 👍 반환타입을 Camera로 더 엄격하게!

function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds); // ✅ 반환타입이 Camera
  setCamera(camera); // Camera타입은 CameraOptions타입에 할당 가능

  const {
    center: { lat, lng }, // ✅ 정상
    zoom,
  } = camera;
  zoom; // 👍 타입이 number
  window.location.search = `?lat=${lat}&lng=${lng}&zoom=${zoom}`;
}
```

---

## item30. 문서에 타입 정보를 쓰지 않기

주석에 변수명과 타입정보를 적지 말아야 한다. 타입 정보에 모순이 발생할 수 있다.

- 주석

  ```tsx
  /**
   * 페이지에 따른 전경색 반환
   * 매개변수는 0또는 1
   * 매개변수가 없을땐 표준 전경색 반환
   */
  function getForegroundColor(page: string) {
    return page == "login" ? { r: 255, g: 255, b: 255 } : { r: 0, g: 0, b: 0 };
  }
  ```

  - 강제하지 않는 이상 주석은 코드와 동기화되지 않는다.

- 코드로 작성
  ```tsx
  /**
   * 페이지에 따른 전경색 반환
   */
  function getForegroundColor(page: string): Color {
    return page == "login" ? { r: 255, g: 255, b: 255 } : { r: 0, g: 0, b: 0 };
  }
  ```
  - 타입구문은 컴파일러가 체크해주기 때문에 구현체와 정합성에 어긋나지 않는다. 따라서 코드가 추후 변경되더라도 정보가 동기화되기때문에 유지보수에 용이하다.

+) 변수명에도 타입을 넣지 않는게 좋다. (`ageNum`❌, `age: number`✅)

---

## item31. 타입 주변에 null값 배치하기
