## Item53. 타입스크립트 기능보다는 ECMAScript기능을 사용하기

자바스크립트에 새로 추가된 기능은 타입스크립트 초기 버전의 기능과 호환성 문제를 발생시켰다.

타입스크립트 진영은 JS 신규 기능을 그대로 채택하고, TS 초기버전과의 호환성을 포기했다. 

이 전에 사용되고 있던 타입공간(TS)와 값공간(JS)의 경계를 혼란스럽게 만드는 기능들이 있는데, 이는 사용하지 않는것이 좋다.

### 열거형(enum)

```tsx
// 1️⃣ 숫자 열거형
enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}
let flavor = Flavor.CHOCOLATE; // flavor: Flavor
Flavor[0]; // 값이 VANILLA
```

타입스크립트 열거형은 상황에 따라 다르게 동작한다.

- 숫자 열거형(Flavor) 에 0,1,2 외의 다른 숫자가 할당되면 위험하다. (원래 비트 플래그 구조를 표현하기 위해 설계되어서) 
→ `let flavor: Flavor = 3;` 같은 케이스는 막힘! (업데이트 된듯)
- 상수 열거형은 런타임에 완전히 제거된다. 앞의 예제를 const enum Flavor로 바꾸면 컴파일러는 Flavor.CHOCOLATE을 0으로 바꿔버린다.
- preserveConstEnums 플래그를 설정한 상태의 상수 열거형은 보통의 열거형처럼 런타임 코드에 상수 열거형 정보를 유지한다.
- 문자열 열거형은 런타임의 타입안정성과 투명성을 제공한다. 하지만 타입스크립트의 구조적 타이핑이 아닌 명목적 타이핑을 사용한다.

```tsx
// 2️⃣ 문자 열거형
enum Flavor2 {
  VANILLA = 'vanilla',
  CHOCOLATE = 'chocolate',
  STRAWBERRY = 'strawberry',
}
let flavor2 = Flavor2.CHOCOLATE; // flavor2: Flavor2
flavor2 = 'strawberry'; // ❌ Type '"strawberry"' is not assignable to type 'Flavor2'

function scoop(flavor: Flavor2): void {
  console.log(`Scoop of ${flavor}`);
}
```

타입스크립트의 다른 타입들은 할당 가능성을 체크하기 위해 구조적 타이핑을 사용하지만, 문자열 열거형은 명목적 타이핑을 사용한다.

```tsx
scoop('vanilla') // JS에선 정상이지만, TS에선 오류 발생
```

- flavor는 런타임시점엔 문자열이기 때문에, JS에서 이렇게 호출 가능.
- 해당 구문은 자바스크립트에선 정상이지만, TS에선 에러를 발생시킨다.

```tsx

import { Flavor } from './enum';
scoop(Flavor2.CHOCOLATE);
```

- 이렇게 열거형을 임포트하고 문자열 대신 사용해야한다.

```tsx
// 👍 enum 대신 리터럴타입의 유니온 사용하기
type Flavor = 'vanilla' | 'chocolate' | 'strawberry';

let flavor: Flavor = 'chocolate';
flavor = 'mint' // ❌ Type '"mint"' is not assignable to type 'Flavor'
```

enum을 사용하지 말고 리터럴 타입의 유니온을 사용해야 한다.

| **특징** | **enum** | **유니언 타입** |
| --- | --- | --- |
| **런타임 존재 여부** | 런타임에 객체로 존재 (Flavor.VANILLA) | 런타임에 제거됨 |
| **타입 안정성** | 명목적 타이핑 (정의된 열거형 값만 허용) | 구조적 타이핑 (정의된 문자열 값만 허용) |
| **가독성** | 열거형 이름으로 값의 의미를 명확히 표현 가능 | 문자열 값만 사용 |
| **성능** | 런타임에 객체를 유지 (숫자/문자열 열거형) | 런타임에 제거되어 더 가볍게 동작 |

### 매개변수 속성

- JS 문법
    
    ```tsx
    class Person {
      name: string;
      constructor(name: string) {
        this.name = name;
      }
    }
    ```
    

- TS 문법
    
    ```tsx
    class Person {
      constructor(public name: string) {}
    }
    ```
    
    - public name → 매개변수 속성
    - 멤버변수로 name을 선언한 이전 예제와 동일하게 동작한다.

매개변수 속성과 관련된 문제점

- TS 컴파일은 타입제거가 이루어지므로 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나는 문법이다.
- 매개변수 속성이 런타임에는 실제로 사용되지만, TS관점에선 사용되지 않는것처럼 보인다.
- 매개변수 속성과 일반속성을 섞어 사용하면 클래스의 설계가 혼란스러워진다.
    
    ```tsx
    class Person {
      first: string;
      last: string;
      // 👎 실제론 name 속성도 존재하지만, name만 매개변수 속성에 존재해서 일관성이 없음!
      
      constructor(public name: string) {
        [this.first, this.last] = name.split(" ");
      }
    }
    ```
    

→ 매개변수 속성은 TS의 다른 패턴들과 이질적이고, 초급자에게 생소하다. 또 매개변수와 일반변수를 같이 쓰면 설계가 혼란스러워질 수 있어 주의해야한다.

### 네임스페이스와 트리플 슬래시 임포터

JS처럼 TS도 자체적으로 모듈시스템을 구축했고, module키워드와 트리플 슬래시 임포트를 사용했다.

하지만 ECMAScript2015가 공식적으로 모듈 시스템을 도입한 이후, TS는 충돌을 피하기 위해 module같은 기능을 하는 namespace를 추가했다.

```tsx
namespace foo {
  function bar() {
    console.log("bar");
  }
}

/// <reference path="other.ts" />
foo.bar();
```

→ 이는 호환성을 위해 남아있을 뿐이니 ECMAScript2015 스타일의 모듈(import, export)을 사용해야한다.

### 데코레이터

데코레이터는 클래스, 메서드, 속성에 어노테이션을 붙이거나 기능을 추가하는데 사용할 수 있다.

어노테이션은 experimentalDecorators 속성을 설정하고 사용해야한다.

아직 표준화가 완료되지 않아 비표준이 되거나 호환성이 깨질 가능성이 있다. 

```tsx
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }

  @logged // Annotation
  greet() {
    return "Hello, " + this.greeting;
  }
}

function logged(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const fn = target[methodName];
  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${methodName} with args: ${args}`);
    return fn.apply(this, args);
  }
}

console.log(new Greeter("world").greet());
// Calling greet with args: []
// Hello, world
```

<aside>
💡

일반적으론 TS코드에서 타입정보를 제거하면 JS가 되지만, 열거형,매개변수 속성, 트리플슬래시 임포트, 데코레이터는 그렇지 않다.

따라서 TS역할을 명확히 하려면 이들을 사용하지 않는것이 좋다.

</aside>

## Item54. 객체를 순회하는 노하우

```tsx
interface ABC {
  a: string,
  b: string,
  c: number
}
```

- for in
    
    ```tsx
    function foo(abc: ABC) {
      for(const k in abc) { // k: string
        const v = abc[k]; // v: any
      }
    }
    ```
    
    - k는 string인 반면, obj엔 ‘a’, ‘b’, ‘c’ 세개의 키만 존재한다 → 편집기에서 오류 발생!
    - k가 string, v가 any인 이유 → 구조적타이핑의 관점에서, obj에 할당 가능한 어떤 값이든 매개변수로 허용함 (`d: new Date()` 같은 값이 오면 이를 허용해야하기 때문에)
    

- keyof
    
    ```tsx
    function foo(abc: ABC) {
      let k: keyof ABC;
      for(k in abc) { // k: "a" | "b" | "c"
        const v = abc[k]; // v: string | number
      }
    }
    ```
    
    - k의 타입을 더 구체적으로 명시해주면 오류는 사라진다
    - 하지만 구조적 타이핑의 관점에서, `d: new Date()`  같은 값이 들어온다면 이 또한 잘못된 추론이 된다.

- Object.entries

```tsx
function foo(abc: ABC) {
  for(const [k, v] of Object.entries(abc)) { // k: string, v: string | number
    k; // k: string
    v; // v: any
  }
}

```

- Object.entries는 복잡한 기교 없이 사용 가능하다.
- 더욱 일반적으로 사용 가능

<aside>
💡

키가 어떤 타입인지 정확히 파악하고 있다면 for-in루프와 keyof를 사용
객체를 순회하며 키와 값을 얻는 가장 일반적인 방법은 Object.entries이다.

</aside>

## Item55. DOM 계층구조 이해하기

DOM 계층은 웹브라우저에서 JS를 실행할 때 어디에서나 존재한다.

TS에선 DOM엘리먼트의 계층구조를 파악하기 용이하다. Element와 EventTarget에 달려있는 Node의 구체적인 타입을 안다면 타입오류를 디버깅 할 수 있고, 언제 타입단언을 사용해야 할 지 알 수 있다. 

```tsx
function handleDrag(eDown: Event) {
  const targetEl =  eDown.currentTarget;
  targetEl.classList.add('dragging'); // ❌ 'targetEl' is possibly 'null'.
  const dragStart = [eDown.clientX, eDown.clientY]; // ❌ Property 'clientX' does not exist on type 'Event'
  
  const handleUp = (eUp: Event) => {
    targetEl.classList.remove('dragging'); // ❌ 'targetEl' is possibly 'null'.
    document.removeEventListener('mouseup', handleUp);
    const dragEnd = [eUp.clientX, eUp.clientY];
  }
  targetEl?.addEventListener('mouseup', handleUp);
}
const div = document.querySelector('.drag');
div.addEventListener('mousedown', handleDrag); // ❌ 'div' is possibly 'null'.
```

```
function addDragHandler(el: HTMLElement) {
  el.addEventListener("mousedown", eDown => { // 👍 eDown: MouseEvent
    const dragStart = [eDown.clientX, eDown.clientY];
    el.classList.add("dragging");
    const handleUp = (eUp: MouseEvent) => {
      el.classList.remove("dragging");
      const dragEnd = [eUp.clientX, eUp.clientY];
    }
    el.addEventListener("mouseup", handleUp);
  });
}
```

- mousedown 이벤트헨들러를 인라인으로 만들어 매개변수타입을 Event가 아닌 MouseEvnet로 만듦

### EventTarget 타입의 계층구조

포함관계 : `HTMLParagraphElement` ⊂`HTMLElement`  ⊂ `Element` ⊂ `Node` ⊂ `EventTarget`

| 타입 | 예시 |
| --- | --- |
| EventTarget | window, XMLHttpRequest |
| Node | document, Text, Commnet |
| Element | HTMLElement, SVGElement |
| HTMLElement | <i>, <b> |
| HTMLButtonElement | <button> |
- EventTarget
    
    EventTarget은 DOM타입중 가장 추상화된 타입이다. 이벤트리스너를 추가/제거, 이벤트를 보내는 것 밖에 할 수 없다.
    
    ```tsx
    function handleDrag(eDown: Event) {
      const targetEl =  eDown.currentTarget;
      targetEl.classList.add('dragging'); // ❌ 'targetEl' is possibly 'null'.
    	...
    }
    ```
    
    Event의 CurrentTarget 속성 타입은 `EventTarget | null` → null가능성 오류로 표기 
    
    EventTarget타입은 실제로 window가 될 수 있기 때문에, classList속성이 없을 수 있다 → 오류로 포기
    
- Node
    
    p.childNodes는 element 뿐 아니라 텍스트조각과 주석까지 포함한다. 이는 Node이다.
    
    ```tsx
    <p>
      And <i>yet</i> it moves
      <!-- This is a comment -->
    </p>
    
    > p.childNodes
    NodeList(5) [text, i, text, comment, text]
    ```
    
- Element, HTMLElement
- HTMLxxxElement
    
    이 형태의 엘리먼트는 자신만의 고유한 속성을 가지고 있다. (HTMLImageElement=src, HTMLInputElement=value)
    
    이런 정보에 접근하려면 타입 정보 역시 실제 엘리먼트 타입이어야 하므로, 구체적으로 타입을 지정해야 한다.
    
    ```tsx
    const btn = document.querySelector('button'); // btn: HTMLButtonElement | null
    const btn2 = document.getElementById('my-btn'); // btn2: HTMLElement | null
    
    const btn3 = document.getElementById('my-btn') as HTMLButtonElement; // 👍 #my-btn이 버튼태그임을 알고 있으면 단언문 사용
    ```
    
    타입단언은 지양해야하지만, Dom관련은 TS보다 우리가 더 정확히 알고 있으므로 단언문을 사용하는게 좋다.
    

### Event의 계층구조

| 타입 | 설명 |
| --- | --- |
| UIEvent | 모든 종류의 사용자 인터페이스 이벤트 |
| MouseEvent | 마우스로부터 발생되는 이벤트 (클릭 등) |
| TouchEvent | 모바일 기기의 터치 이벤트 |
| WheelEvent | 스크롤 휠을 돌려서 발생되는 이벤트 |
| KeyboardEvent | 키 누름 이벤트 |

```tsx
function handleDrag(eDown: Event) {
	...
  const dragStart = [eDown.clientX, eDown.clientY]; // ❌ Property 'clientX' does not exist on type 'Event'
	...
}
```

clientX, clientY은 MouseEvent타입에 존재하는 반면, 매개변수가 더 넓은 범위인 Event이므로 에러가 발생한다.

## Item56. 정보를 감추는 목적으로 private 사용하지 않기

JS는 클래스에 비공개 속성을 만들 수 없고, 언더스코어(_) 접두사를 붙이던 것이 관례로 인정되고 있다. 

하지만 TS엔 public, protected, private 접근 제어자를 이용할 수 있지만, 이것이 규칙을 강제하는건 아니다.

```tsx
class Diary {
  private secret = 'cheated on my Test';
}

const diary = new Diary();
diary.secret; // ❌ Property 'secret' is private and only accessible within class 'Diary'.
(diary as any).secret; // ✅ 타입 단언 사용하면 TS에서도 접근 가능
```

접근제어자 private은 TS 키워드이기 때문에, 컴파일 이후엔 제거된다. 런타임이나 타입단언문을 사용하면 접근 가능하다.

따라서 정보를 감추기 위해 Private을 사용해선 안된다.

## Item57. 소스맵을 사용하여 타입스크립트 디버깅하기