## Item53. 타입스크립트 기능보다는 ECMAScript기능을 사용하기

자바스크립트에 새로 추가된 기능은 타입스크립트 초기 버전의 기능과 호환성 문제를 발생시켰다.

타입스크립트 진영은 JS 신규 기능을 그대로 채택하고, TS 초기버전과의 호환성을 포기했다. 

이 전에 사용되고 있던 타입공간(TS)와 값공간(JS)의 경계를 혼란스럽게 만드는 기능들이 있는데, 이는 사용하지 않는것이 좋다.

### 열거형(enum)

```tsx
// 1️⃣ 숫자 열거형
enum Flavor {
  VANILLA = 0,
  CHOCOLATE = 1,
  STRAWBERRY = 2,
}
let flavor = Flavor.CHOCOLATE; // flavor: Flavor
Flavor[0]; // 값이 VANILLA
```

타입스크립트 열거형은 상황에 따라 다르게 동작한다.

- 숫자 열거형(Flavor) 에 0,1,2 외의 다른 숫자가 할당되면 위험하다. (원래 비트 플래그 구조를 표현하기 위해 설계되어서) 
→ `let flavor: Flavor = 3;` 같은 케이스는 막힘! (업데이트 된듯)
- 상수 열거형은 런타임에 완전히 제거된다. 앞의 예제를 const enum Flavor로 바꾸면 컴파일러는 Flavor.CHOCOLATE을 0으로 바꿔버린다.
- preserveConstEnums 플래그를 설정한 상태의 상수 열거형은 보통의 열거형처럼 런타임 코드에 상수 열거형 정보를 유지한다.
- 문자열 열거형은 런타임의 타입안정성과 투명성을 제공한다. 하지만 타입스크립트의 구조적 타이핑이 아닌 명목적 타이핑을 사용한다.

```tsx
// 2️⃣ 문자 열거형
enum Flavor2 {
  VANILLA = 'vanilla',
  CHOCOLATE = 'chocolate',
  STRAWBERRY = 'strawberry',
}
let flavor2 = Flavor2.CHOCOLATE; // flavor2: Flavor2
flavor2 = 'strawberry'; // ❌ Type '"strawberry"' is not assignable to type 'Flavor2'

function scoop(flavor: Flavor2): void {
  console.log(`Scoop of ${flavor}`);
}
```

타입스크립트의 다른 타입들은 할당 가능성을 체크하기 위해 구조적 타이핑을 사용하지만, 문자열 열거형은 명목적 타이핑을 사용한다.

```tsx
scoop('vanilla') // JS에선 정상이지만, TS에선 오류 발생
```

- flavor는 런타임시점엔 문자열이기 때문에, JS에서 이렇게 호출 가능.
- 해당 구문은 자바스크립트에선 정상이지만, TS에선 에러를 발생시킨다.

```tsx

import { Flavor } from './enum';
scoop(Flavor2.CHOCOLATE);
```

- 이렇게 열거형을 임포트하고 문자열 대신 사용해야한다.

```tsx
// 👍 enum 대신 리터럴타입의 유니온 사용하기
type Flavor = 'vanilla' | 'chocolate' | 'strawberry';

let flavor: Flavor = 'chocolate';
flavor = 'mint' // ❌ Type '"mint"' is not assignable to type 'Flavor'
```

enum을 사용하지 말고 리터럴 타입의 유니온을 사용해야 한다.

| **특징** | **enum** | **유니언 타입** |
| --- | --- | --- |
| **런타임 존재 여부** | 런타임에 객체로 존재 (Flavor.VANILLA) | 런타임에 제거됨 |
| **타입 안정성** | 명목적 타이핑 (정의된 열거형 값만 허용) | 구조적 타이핑 (정의된 문자열 값만 허용) |
| **가독성** | 열거형 이름으로 값의 의미를 명확히 표현 가능 | 문자열 값만 사용 |
| **성능** | 런타임에 객체를 유지 (숫자/문자열 열거형) | 런타임에 제거되어 더 가볍게 동작 |

### 매개변수 속성

- JS 문법
    
    ```tsx
    class Person {
      name: string;
      constructor(name: string) {
        this.name = name;
      }
    }
    ```
    

- TS 문법
    
    ```tsx
    class Person {
      constructor(public name: string) {}
    }
    ```
    
    - public name → 매개변수 속성
    - 멤버변수로 name을 선언한 이전 예제와 동일하게 동작한다.

매개변수 속성과 관련된 문제점

- TS 컴파일은 타입제거가 이루어지므로 코드가 줄어들지만, 매개변수 속성은 코드가 늘어나는 문법이다.
- 매개변수 속성이 런타임에는 실제로 사용되지만, TS관점에선 사용되지 않는것처럼 보인다.
- 매개변수 속성과 일반속성을 섞어 사용하면 클래스의 설계가 혼란스러워진다.
    
    ```tsx
    class Person {
      first: string;
      last: string;
      // 👎 실제론 name 속성도 존재하지만, name만 매개변수 속성에 존재해서 일관성이 없음!
      
      constructor(public name: string) {
        [this.first, this.last] = name.split(" ");
      }
    }
    ```
    

→ 매개변수 속성은 TS의 다른 패턴들과 이질적이고, 초급자에게 생소하다. 또 매개변수와 일반변수를 같이 쓰면 설계가 혼란스러워질 수 있어 주의해야한다.

### 네임스페이스와 트리플 슬래시 임포터

JS처럼 TS도 자체적으로 모듈시스템을 구축했고, module키워드와 트리플 슬래시 임포트를 사용했다.

하지만 ECMAScript2015가 공식적으로 모듈 시스템을 도입한 이후, TS는 충돌을 피하기 위해 module같은 기능을 하는 namespace를 추가했다.

```tsx
namespace foo {
  function bar() {
    console.log("bar");
  }
}

/// <reference path="other.ts" />
foo.bar();
```

→ 이는 호환성을 위해 남아있을 뿐이니 ECMAScript2015 스타일의 모듈(import, export)을 사용해야한다.

### 데코레이터

데코레이터는 클래스, 메서드, 속성에 어노테이션을 붙이거나 기능을 추가하는데 사용할 수 있다.

어노테이션은 experimentalDecorators 속성을 설정하고 사용해야한다.

아직 표준화가 완료되지 않아 비표준이 되거나 호환성이 깨질 가능성이 있다. 

```tsx
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }

  @logged // Annotation
  greet() {
    return "Hello, " + this.greeting;
  }
}

function logged(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const fn = target[methodName];
  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${methodName} with args: ${args}`);
    return fn.apply(this, args);
  }
}

console.log(new Greeter("world").greet());
// Calling greet with args: []
// Hello, world
```

<aside>
💡

일반적으론 TS코드에서 타입정보를 제거하면 JS가 되지만, 열거형,매개변수 속성, 트리플슬래시 임포트, 데코레이터는 그렇지 않다.

따라서 TS역할을 명확히 하려면 이들을 사용하지 않는것이 좋다.

</aside>

## Item54. 객체를 순회하는 노하우

```tsx
interface ABC {
  a: string,
  b: string,
  c: number
}
```

- for in
    
    ```tsx
    function foo(abc: ABC) {
      for(const k in abc) { // k: string
        const v = abc[k]; // v: any
      }
    }
    ```
    
    - k는 string인 반면, obj엔 ‘a’, ‘b’, ‘c’ 세개의 키만 존재한다 → 편집기에서 오류 발생!
    - k가 string, v가 any인 이유 → 구조적타이핑의 관점에서, obj에 할당 가능한 어떤 값이든 매개변수로 허용함 (`d: new Date()` 같은 값이 오면 이를 허용해야하기 때문에)
    

- keyof
    
    ```tsx
    function foo(abc: ABC) {
      let k: keyof ABC;
      for(k in abc) { // k: "a" | "b" | "c"
        const v = abc[k]; // v: string | number
      }
    }
    ```
    
    - k의 타입을 더 구체적으로 명시해주면 오류는 사라진다
    - 하지만 구조적 타이핑의 관점에서, `d: new Date()`  같은 값이 들어온다면 이 또한 잘못된 추론이 된다.

- Object.entries

```tsx
function foo(abc: ABC) {
  for(const [k, v] of Object.entries(abc)) { // k: string, v: string | number
    k; // k: string
    v; // v: any
  }
}

```

- Object.entries는 복잡한 기교 없이 사용 가능하다.
- 더욱 일반적으로 사용 가능

<aside>
💡

키가 어떤 타입인지 정확히 파악하고 있다면 for-in루프와 keyof를 사용
객체를 순회하며 키와 값을 얻는 가장 일반적인 방법은 Object.entries이다.

</aside>

## Item55. DOM 계층구조 이해하기

DOM 계층은 웹브라우저에서 JS를 실행할 때 어디에서나 존재한다.

TS에선 DOM엘리먼트의 계층구조를 파악하기 용이하다. Element와 EventTarget에 달려있는 Node의 구체적인 타입을 안다면 타입오류를 디버깅 할 수 있고, 언제 타입단언을 사용해야 할 지 알 수 있다. 

```tsx
function handleDrag(eDown: Event) {
  const targetEl =  eDown.currentTarget;
  targetEl.classList.add('dragging'); // ❌ 'targetEl' is possibly 'null'.
  const dragStart = [eDown.clientX, eDown.clientY]; // ❌ Property 'clientX' does not exist on type 'Event'
  
  const handleUp = (eUp: Event) => {
    targetEl.classList.remove('dragging'); // ❌ 'targetEl' is possibly 'null'.
    document.removeEventListener('mouseup', handleUp);
    const dragEnd = [eUp.clientX, eUp.clientY];
  }
  targetEl?.addEventListener('mouseup', handleUp);
}
const div = document.querySelector('.drag');
div.addEventListener('mousedown', handleDrag); // ❌ 'div' is possibly 'null'.
```

```
function addDragHandler(el: HTMLElement) {
  el.addEventListener("mousedown", eDown => { // 👍 eDown: MouseEvent
    const dragStart = [eDown.clientX, eDown.clientY];
    el.classList.add("dragging");
    const handleUp = (eUp: MouseEvent) => {
      el.classList.remove("dragging");
      const dragEnd = [eUp.clientX, eUp.clientY];
    }
    el.addEventListener("mouseup", handleUp);
  });
}
```

- mousedown 이벤트헨들러를 인라인으로 만들어 매개변수타입을 Event가 아닌 MouseEvnet로 만듦

### EventTarget 타입의 계층구조

포함관계 : `HTMLParagraphElement` ⊂`HTMLElement`  ⊂ `Element` ⊂ `Node` ⊂ `EventTarget`

| 타입 | 예시 |
| --- | --- |
| EventTarget | window, XMLHttpRequest |
| Node | document, Text, Commnet |
| Element | HTMLElement, SVGElement |
| HTMLElement | <i>, <b> |
| HTMLButtonElement | <button> |
- EventTarget
    
    EventTarget은 DOM타입중 가장 추상화된 타입이다. 이벤트리스너를 추가/제거, 이벤트를 보내는 것 밖에 할 수 없다.
    
    ```tsx
    function handleDrag(eDown: Event) {
      const targetEl =  eDown.currentTarget;
      targetEl.classList.add('dragging'); // ❌ 'targetEl' is possibly 'null'.
    	...
    }
    ```
    
    Event의 CurrentTarget 속성 타입은 `EventTarget | null` → null가능성 오류로 표기 
    
    EventTarget타입은 실제로 window가 될 수 있기 때문에, classList속성이 없을 수 있다 → 오류로 포기
    
- Node
    
    p.childNodes는 element 뿐 아니라 텍스트조각과 주석까지 포함한다. 이는 Node이다.
    
    ```tsx
    <p>
      And <i>yet</i> it moves
      <!-- This is a comment -->
    </p>
    
    > p.childNodes
    NodeList(5) [text, i, text, comment, text]
    ```
    
- Element, HTMLElement
- HTMLxxxElement
    
    이 형태의 엘리먼트는 자신만의 고유한 속성을 가지고 있다. (HTMLImageElement=src, HTMLInputElement=value)
    
    이런 정보에 접근하려면 타입 정보 역시 실제 엘리먼트 타입이어야 하므로, 구체적으로 타입을 지정해야 한다.
    
    ```tsx
    const btn = document.querySelector('button'); // btn: HTMLButtonElement | null
    const btn2 = document.getElementById('my-btn'); // btn2: HTMLElement | null
    
    const btn3 = document.getElementById('my-btn') as HTMLButtonElement; // 👍 #my-btn이 버튼태그임을 알고 있으면 단언문 사용
    ```
    
    타입단언은 지양해야하지만, Dom관련은 TS보다 우리가 더 정확히 알고 있으므로 단언문을 사용하는게 좋다.
    

### Event의 계층구조

| 타입 | 설명 |
| --- | --- |
| UIEvent | 모든 종류의 사용자 인터페이스 이벤트 |
| MouseEvent | 마우스로부터 발생되는 이벤트 (클릭 등) |
| TouchEvent | 모바일 기기의 터치 이벤트 |
| WheelEvent | 스크롤 휠을 돌려서 발생되는 이벤트 |
| KeyboardEvent | 키 누름 이벤트 |

```tsx
function handleDrag(eDown: Event) {
	...
  const dragStart = [eDown.clientX, eDown.clientY]; // ❌ Property 'clientX' does not exist on type 'Event'
	...
}
```

clientX, clientY은 MouseEvent타입에 존재하는 반면, 매개변수가 더 넓은 범위인 Event이므로 에러가 발생한다.

## Item56. 정보를 감추는 목적으로 private 사용하지 않기

JS는 클래스에 비공개 속성을 만들 수 없고, 언더스코어(_) 접두사를 붙이던 것이 관례로 인정되고 있다. 

하지만 TS엔 public, protected, private 접근 제어자를 이용할 수 있지만, 이것이 규칙을 강제하는건 아니다.

```tsx
class Diary {
  private secret = 'cheated on my Test';
}

const diary = new Diary();
diary.secret; // ❌ Property 'secret' is private and only accessible within class 'Diary'.
(diary as any).secret; // ✅ 타입 단언 사용하면 TS에서도 접근 가능
```

접근제어자 private은 TS 키워드이기 때문에, 컴파일 이후엔 제거된다. 런타임이나 타입단언문을 사용하면 접근 가능하다.

따라서 정보를 감추기 위해 Private을 사용해선 안된다.

## Item57. 소스맵을 사용하여 타입스크립트 디버깅하기

TS코드를 실행한다는 것은, TS 컴파일러가 생성한 JS 코드를 실행한다는것이다. 디버깅 시점에 볼 수 있는것은 전처리, 컴파일러, 압축기를 거친 JS코드고, 이를 디버깅하기는 매우 어렵다.

### 소스맵 (source map)

소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 매핑한다. 

# 8장. 타입스크립트로 마이그레이션하기

## Item58. 모던 자바스크립트 작성하기

### ECMAScript 모듈 사용하기

ES2015 이후엔 개별 모듈로 분할하는 방법이 많아졌다. (<script>태그 여러개 생성, 직접 갖다 붙이기, MakeFile기법, NodeJS require 등)

ES2015부턴 ECMAScript모듈 (import, export)가 표준이 되었으므로, 비표준모듈시스템을 이용중이라면 ES모듈로 전환하는게 좋다. 프로젝트 종률에 따라 webpack이나 ts-node가 필요한 경우가 있다.

```tsx
// Common JS
const b= require('./b.js');
console.log(b.name);
// b.js
const name = 'b';
module.exports = {name};
```

```tsx
// ES Module
import { name } from './b.js';
console.log(name);
// b.js
export const name = 'b';
```

### 프로토타입 대신 클래스 사용하기

과거에는 JS에서 프로토타입 기반의 객체모델을 사용했다. 하지만 ES2015엔 class 키워드를 사용하는 클래스 기반 모델이 도입되었따.

마이그레이션 하는 코드에서 프로토타입을 사용하고 있었다면, 클래스로 바꾸는것이 좋다. ej wlrrhkswjrdlrh rksrufgowlsek.

```tsx
function Person(first, last) {
  this.firstName = first;
  this.lastName = last;
}

Person.prototype.getFullName = function() {
  return this.firstName + " " + this.lastName;
};

const marie = new Person("Marie", "Curie");
const personName = marie.getFullName();
```

```tsx
class Person {
  constructor(first, last) {
    this.firstName = first;
    this.lastName = last;
  }

  getFullName() {
    return this.firstName + " " + this.lastName;
  }
}
```

### var 대신 let/const 사용하기

var키워드엔 스코프 규칙에 문제가 있다. let과 const는 제대로 된 블록 스코프 규칙을 가지므로 이로 대체해야한다.

### for(;;) 대신 for-of 또는 배열 메서드 사용하기

for-of 루프는 코드가 짧고 인덱스 변수도 사용하지 않아 실수를 줄일 수 있다.

### 함수표현식보다 화살표함수 사용하기

this키워드는 다른 스코프 규칙을 가져 예상치 못한 결과를 만들 수 있다. 

```tsx
class Foo {
  method() {
    console.log(this);
    [1,2].forEach(function (item) {
      console.log(this);
    }
    );
  }
}

const f = new Foo();
f.method();
// Output:
// strict mode: Foo, undefined, undefined
// non-strict mode: Foo, window, window
```

하지만 화살표 함수를 사용하면 상위 스코프의 this를 유지할 수 있다. 

```tsx
class Foo {
  method() {
    console.log(this);
    [1,2].forEach(i => {
      console.log(this);
    }
    );
  }
}

const f = new Foo();
f.method();
// Output: Foo, Foo, Foo
```

- 🤖 GPT 설명
    - **strict mode**는 자바스크립트의 엄격한 모드로, `this`의 동작을 더 안전하게 만듭니다.
    - 주요 차이점:
        - **strict mode**: 함수 내부에서 `this`가 명시적으로 바인딩되지 않으면 `undefined`가 됩니다.
        - **non-strict mode**: 함수 내부에서 `this`가 명시적으로 바인딩되지 않으면 전역 객체(`window` 또는 `global`)를 참조합니다.

### 단축 객체 표현과 구조 분해 할당 사용하기

- 단축 객체표현
    
    ```tsx
    // ❌
    const pt = {
      x: x,
      y: y,
      z: z,
    }
    
    // ✅ zhemrk ej rksrufgkek!
    const pt = {x,y,z};
    ```
    

- 객체 구조분해

```tsx
// ❌
const props = object.props;

// ✅
const {props} = object;
const [x,y,z] = point;
```

### 함수 매개변수 기본값 사용하기

```tsx
// ❌
function parseNum(str, base) {
  return parseInt(str, base);
}

// ✅
function parseNum(str, base=10) {
  return parseInt(str, base);
}
```

코드가 간결해지고, base가 선택적 매개변수라는 것을 명확히 나타낼 수 있다.

### 저수준 프로미스나 콜백 대신 async/await 사용하기

async/await을 사용하면 코드가 간결해저 버그나 실수를 방지할 수 있고, 비동기코드에 타입정보가 전달되어 타입추론을 가능하게 한다.

```tsx
// ❌
function getJSON(url: string) {
  return fetch(url).then(response => response.json());
}

// ✅
async function getJSON(url: string) {
  const response = await fetch(url);
  return response.json();
}
```

### 연관 배열에 객체 대신 Map과 Set 사용하기

```tsx
function countWords(text: string) {
  const counts: {[word:string]:number} = {};
  for(const word of text.split(/\s+/)) {
    if (word.length > 0) {
      counts[word] = (counts[word] || 0) + 1;
    }
  }
  return counts;
}
```

만약 ‘constructor’라는 문자열이 주어지면 에러가 발생함 

→ Object.prototype에 있는 생성자 함수와 겹치기 때문! 타입도 number가 아닌 string이다.

```tsx
function countWordsMap(text: string) {
  const counts: Map<string, number> = new Map();
  for(const word of text.split(/\s+/)) {
    if (word.length > 0) {
      counts.set(word, (counts.get(word) || 0) + 1);
    }
  }
  return counts;
}
```

### 타입스크립트에 use strict 넣지 않기

코드의 제일 처음에 ‘`use strict`’를 넣으면 엄격모드를 활성화할 수 있다.

하지만 TS의 안정성검사(sanity check)가 훨씬 더 엄격하기때문에, 코드내부의 use strict는 무의미하다

또 `alwaysStrict` 또는 `strict` 컴파일러 옵션을 설정하면, TS는 엄격모드로 코드를 파싱하고 JS에 use strict를 추가하므로 이를 사용해야한다.

## Item59. 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해보기

본격적으로 TS로 전환하기 전, @ts-check를 사용하면 TS전환 시 어떤 문제가 나오는지 미리 시험해볼 수 있다.

하지만 이는 매우 느슨한 수준이고, noImplicityAny 해제한거보다 헐거운 체크를 수행한다.

```tsx
// @ts-check
const person = {first:"John", last: "Doe"};

2 * person.first // The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type.
```

@ts-check 지시자 덕분에 js파일에서도 타입체크가 동작한다.

또한 JsDoc 주석을 잘 활용하면 JS상태에서도 타입 단언과 타입 추론을 할 수 있다.

## Item60. allowJs로 타입스크립트와 자바스크립트 같이 사용하기

대규모 프로젝트의 경우엔 점진적으로 전환할 수 있기 때문에, JS와 TS가 동시에 동작할 수 있도록 해야한다.

`allowJS` 컴파일러 옵션을 사용하면 TS파일과 JS파일을 서로 임포트할 수 있게 해준다.

## Item61. 의존성 관계에 따라 모듈 단위로 전환하기