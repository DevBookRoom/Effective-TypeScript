## Item38. any타입은 가능한 한 좁은 범위에서만 사용하기

```tsx
function f1() {
  const x: any = expressionReturningFoo(); // ❌ any가 다른 모든 코드에 영향을 줌
  processBar(x);
}

function f2() {
  const x = expressionReturningFoo();
  processBar(x as any); // ✅ any가 processBar 안에서만 영향을 줌
}
```

aksdir x라는 변수가 동시에 Foo타입과 Bar 타입에 할당 가능하다면, 후자의 방식을 택해야 한다.

processBar의 매개변수에서만 사용된 표현식이므로, 다른 코드에 영향을 미치지 않는다.

```tsx
function f1() {
  const x: any = expressionReturningFoo();
  // @ts-ignore
  processBar(x);
}
```

혹은 @ts-ignore를 사용하여 해당 주석 다음줄의 오류를 무시하도록 해야한다.

```tsx
const config: Config = {
  a: 1,
  b: 2,
  c: {
    key: "value", // 만약 여기서 에러가 발생한다면??
  },
};

const config: Config = {
  a: 1,
  b: 2,
  c: {
    key: "value",
  },
} as any; // ❌ 객체 전체를 any로 단언하면 안됨!

const config: Config = {
  a: 1,
  b: 2,
  c: {
    key: "value" as any, // ✅에러가 나는 속성에서만 any 사용하기
  },
};
```

또 객체의 일부 속성에서만 에러가 발생한다면, 객체 전체를 any로 하지 말고 최소한의 범위에서만 any를 사용해야한다.

## item39. any를 구체적으로 변형해서 사용하기

```tsx
function getLengthBad(array: any) {
  return array.length; // 👎 length타입이 체크되지 않음
}

function getLengthGood(array: any[]) {
  // 👍 매개변수가 배열인지 체크됨
  return array.length; // 👍 length타입이 체크되고, 타입도 Number로 추론됨
}
```

그냥 any를 사용하는 것 보다, any[]를 사용하는게 더 좋다. 함수의 length타입이 체크되고, 반환타입 또한 number로 추론된다.

```tsx
function hasTwelveLetterKey(obj: { [key: string]: any }) {
  for (const key in obj) {
    if (key.length === 12) {
      console.log(key, obj[key]);
      return true;
    }
  }
  return false;
}
```

함수의 매개변수가 객체이지만 값을 알 수 없다면, `{ [key: string]: any }` 처럼 선언할 수 있다.

```tsx
type fn0 = () => any; // 매개변수가 없는 함수
type fn1 = (arg: any) => any; // 매개변수가 하나인 함수
type fn2 = (...args: any[]) => any; // 매개변수가 여러 개인 함수
```

함수의 타입에도 단순히 any를 쓰기 보다는, 다음과 같이 매개변수의 개수를 최소한으로나마 구체화할 수 있다.

## Item40. 함수 안으로 타입 단언문 감추기

타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 현실적인 해결책이 되기도 한다.

불가피하게 사용해야한다면, 정확한 정의를 가지는 함수 안으로 숨겨야한다.

아래의 케이스도 any가 많이 사용되었지만, 타입정의에는 any가 없기 때문에 cacheLast를 호출하는 쪽에서는 any가 사용됐는지 알 수 없다.

```tsx
function cacheLast<T extends Function>(fn: T): T {
  let lastArgs: any[] | null = null;
  let lastResult: any;
  return function (...args: any[]) {
    if (!lastArgs || !shallowEqual(lastArgs, args)) {
      lastResult = fn(...args);
      lastArgs = args;
    }
    return lastResult;
  } as unknown as T;
}
```

## Item41. any의 진화를 이해하기
